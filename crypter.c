// Copyright 2020 (C) Julian Huch
// Autor: Julian Huch

#include "crypter.h"

const char* kFileName;

// ____________________________________________________________________________
struct _NODE
{
    char* buffer;
    size_t size;
};

// ____________________________________________________________________________
bool checkArguments(DWORD argCount, char** argVector)
{
    if ( argCount != 2 )
    {
        fprintf(stdout, "Options:\n");
        fprintf(stdout, "%10s <filename>\n", *(argVector+0));
        return 0;
    }
    kFileName = *(argVector+1);
    return 1;
}

// ____________________________________________________________________________
bool openExecutable(PARAMS* data)
{
    // Declare variables for the function.
    size_t result;

    // File pointer.
    FILE* filePtr;
    // Open file.
    filePtr = fopen(kFileName, "rb");
    // Check if the filename exist and is readable.
    if ( filePtr == NULL ) { return 0; }
    
    // Get size of chars in file and allocate memory.
    (*data).size = ftell(filePtr);
    (*data).buffer = (char*) malloc((sizeof(char)*(*data).size));
    // Check if there's a problem with allocating memory.
    if ( (*data).buffer == NULL ) { return 0; }
    
    // Set the file poiter to the first byte.
    // fseek(filePtr, 0, SEEK_SET);
    rewind(filePtr);

    // Copy the file into the memory buffer.
    result = fread((*data).buffer, 1, (*data).size, filePtr);
    // Check if there's an error with reading the file.
    if ( result != (*data).size ) { return 0; }

    // The file is now loaded in the memory buffer.
    // Close the file.
    fclose(filePtr);
    return 1;
}

// ____________________________________________________________________________
void encryptExecutable(PARAMS* data)
{
    DWORD key = 128;
    for ( int i = 0; i < (*data).size; ++i )
    {
       *((*data).buffer+i) ^= key;
    }
}

// ____________________________________________________________________________
bool writeExecutable(PARAMS* data)
{
    FILE* filePtr;
    filePtr = fopen(kFileName, "wb");
    if ( filePtr == NULL ) { return 0; }
    
    rewind(filePtr);
    // fseek(filePtr, 0, SEEK_SET);
    
    fwrite((*data).buffer, 1, (*data).size, filePtr);

    // Close file.
    fclose(filePtr);
}

// ____________________________________________________________________________
void freeBuffer(PARAMS* data)
{
    free((*data).buffer);
    free(data);
}

