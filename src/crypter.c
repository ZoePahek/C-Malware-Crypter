// Copyright 2020 (C) Julian Huch
// Autor: Julian Huch

#include "crypter.h"

const char* kFileName;

// ____________________________________________________________________________
bool checkArguments(DWORD argCount, char** argVector)
{
    if ( argCount == 1 )
    {
        fprintf(stdout, "One argument needed.\n");
        fprintf(stdout, "-h             -- for help message.\n");
        return 0;
    }

    int opt = getopt(argCount, argVector, ":hf:");
    while( opt != -1 )
    {
        switch(opt)
        {
         case 'h':
            fprintf(stdout, "[HELP]\n");
            fprintf(stdout, "Options:\n");
            fprintf(stdout, "%10s -f <filename>     -- specify file.\n", *(argVector+0));    
            fprintf(stdout, "%10s -h                -- for help message.\n", *(argVector+0));
            return 0;
        case 'f':
            kFileName = optarg;
            return 1;
        case ':':
            fprintf(stdout, "option: %c needs a value\n", optopt);
            return 0;
        case '?':
            fprintf(stdout, "unknown option: %c\n", optopt);
            return 0;
        }
    }
}

// ____________________________________________________________________________
bool openExecutable(PARAMS* data)
{
    // Declare variables for the function.
    size_t result;

    // File pointer.
    FILE* filePtr;
    // Open file.
    filePtr = fopen(kFileName, "rb");
    // Check if the filename exist and is readable.
    if ( filePtr == NULL ) { return 0; }
    
    // Get size of chars in file and allocate memory.
    fseek(filePtr, 0, SEEK_END);    // Set file pointer on the EOF.
    (*data).size = ftell(filePtr);  // Read the position of the file pointer.
    (*data).buffer = (char*) malloc((sizeof(char)*(*data).size));
    // Check if there's a problem with allocating memory.
    if ( (*data).buffer == NULL ) { return 0; }
    
    // Set the file poiter to the first byte.
    // fseek(filePtr, 0, SEEK_SET);
    rewind(filePtr);

    // Copy the file into the memory buffer.
    result = fread((*data).buffer, 1, (*data).size, filePtr);
    // Check if there's an error with reading the file.
    if ( result != (*data).size ) { return 0; }

    // The file is now loaded in the memory buffer.
    // Close the file.
    fclose(filePtr);
    return 1;
}

// ____________________________________________________________________________
void encryptExecutable(PARAMS* data)
{
    DWORD key = 128;
    for ( int i = 0; i < (*data).size; ++i )
    {
       *((*data).buffer+i) ^= key;
    }
}

// ____________________________________________________________________________
bool writeExecutable(PARAMS* data)
{
    FILE* filePtr;
    filePtr = fopen(kFileName, "wb");
    if ( filePtr == NULL ) { return 0; }
    
    rewind(filePtr);
    // fseek(filePtr, 0, SEEK_SET);
    
    fwrite((*data).buffer, 1, (*data).size, filePtr);

    // Close file.
    fclose(filePtr);
    return 1;
}

// ____________________________________________________________________________
void freeBuffer(PARAMS* data)
{
    free((*data).buffer);
    free(data);
}

